<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aomi</title>
    <link>https://aomi.run/</link>
    <description>Recent content on Aomi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_CN</language>
    <copyright>aomi.run</copyright>
    <lastBuildDate>Wed, 20 Jan 2021 23:42:51 +0800</lastBuildDate>
    
	<atom:link href="https://aomi.run/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>实现收到IBMMQ的数据之后存储到数据库(微服务系列第五天)</title>
      <link>https://aomi.run/posts/java/hello-java-5-day/</link>
      <pubDate>Mon, 01 Feb 2021 18:14:10 +0800</pubDate>
      
      <guid>https://aomi.run/posts/java/hello-java-5-day/</guid>
      <description>前言 今天的目标是： 实现收到MQ队列消息，实现收到IBMMQ的数据之后存储到数据库。
 注意!!! 这是个学习使用mybatis的示例工程,正式项目则不应该如此做,耦合很严重.正确的做法是把消息发送到topic上面,由存储服务去topic上面取数据再做保存,这样就可以解耦了.
 修改mqserver项目 pom.xml 添加依赖 此处用的是阿里的连接池 druid
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.4&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.4&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; JDBC 配置 这个是从官网例子上拿来的配置数据
# 只有下面三个是必填项（使用内嵌数据库的话这三个也可以不用填，会使用默认配置），其他配置不是必须的 spring.datasource.url=jdbc:mysql://172.25.0.2:3306/db1 spring.datasource.username=root spring.datasource.password=123456 # driver-class-name 非必填可根据url推断 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # Druid 数据源配置，继承spring.datasource.* 配置，相同则覆盖 spring.datasource.initial-size=2 spring.datasource.max-active=30 spring.datasource.min-idle=2 spring.datasource.max-wait=1234 spring.datasource.pool-prepared-statements=true spring.datasource.max-pool-prepared-statement-per-connection-size=5 # spring.datasource.max-open-prepared-statements= #等价于上面的max-pool-prepared-statement-per-connection-size spring.datasource.validation-query=select 1 spring.datasource.validation-query-timeout=1 spring.datasource.test-on-borrow=true spring.datasource.test-on-return=true spring.datasource.test-while-idle=true spring.datasource.time-between-eviction-runs-millis=10000 spring.datasource.min-evictable-idle-time-millis=30001 spring.datasource.async-close-connection-enable=true # spring.datasource.aop-patterns=com.alibaba.spring.boot.demo.service.* # 自定义StatFilter 配置 其他 Filter 不再演示 spring.datasource.filter.stat.db-type=h2 spring.</description>
    </item>
    
    <item>
      <title>实现java的rsa加解密与签名并调用RPC微服务(微服务系列第四天)</title>
      <link>https://aomi.run/posts/java/hello-java-4-day/</link>
      <pubDate>Sun, 31 Jan 2021 15:40:31 +0800</pubDate>
      
      <guid>https://aomi.run/posts/java/hello-java-4-day/</guid>
      <description>前言  学习java的第4天 实现目标： 实现java的rsa加解密与签名并调用RPC微服务
 实现RSA工具类 由于刚开始学习，本过程是边网上抄作业，边理解。
JDK1.8 的 base64 src/main/java/com/example/rsaserver/utils/JavaBase64Util.java
public class JavaBase64Util { public static final String UTF_8 = &amp;#34;UTF-8&amp;#34;; public static Base64.Encoder encoder; public static Base64.Encoder urlEncoder; public static Base64.Decoder decoder; public static Base64.Decoder urlDecoder; static { encoder = Base64.getEncoder(); urlEncoder = Base64.getUrlEncoder(); decoder = Base64.getDecoder(); urlDecoder = Base64.getUrlDecoder(); } /** * encode * @param bytes * @return byte[] */ public static byte[] encode(final byte[] bytes) { return encoder.</description>
    </item>
    
    <item>
      <title>实现客户端同步和异步调用RPC微服务(微服务系列第三天)</title>
      <link>https://aomi.run/posts/java/hello-java-3-day/</link>
      <pubDate>Thu, 28 Jan 2021 18:16:06 +0800</pubDate>
      
      <guid>https://aomi.run/posts/java/hello-java-3-day/</guid>
      <description>前言  学习java的第3天 实现目标： 学习tars 客户端同步和异步调用RPC服务
 前面搞了那么多环境，主要还是为了折腾多语言微服务开发架构，这样就不用只限定某一种开发语言了，各种语言谁行谁上。今天主要目的就是把前面做的服务端程序，使用客户端来调用。
客户端同步/单向/异步调用服务 构建客户端工程项目,提供WEB代理服务 创建方法有很多种，具体不多说了，自行创建maven项目
添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.tencent.tars&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;tars-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.2&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.tencent.tars&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;tars-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 添加插件 &amp;lt;build&amp;gt; &amp;lt;finalName&amp;gt;mqwebservice&amp;lt;/finalName&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;!--tars2java plugin --&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;com.tencent.tars&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;tars-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.2&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;tars2JavaConfig&amp;gt; &amp;lt;!-- tars文件位置 --&amp;gt; &amp;lt;tarsFiles&amp;gt; &amp;lt;tarsFile&amp;gt;${basedir}/src/main/resources/mqserver.tars&amp;lt;/tarsFile&amp;gt; &amp;lt;/tarsFiles&amp;gt; &amp;lt;!-- 源文件编码 --&amp;gt; &amp;lt;tarsFileCharset&amp;gt;UTF-8&amp;lt;/tarsFileCharset&amp;gt; &amp;lt;!-- 生成代码，PS：客户端调用，这里需要设置为false --&amp;gt; &amp;lt;servant&amp;gt;false&amp;lt;/servant&amp;gt; &amp;lt;!-- 生成源代码编码 --&amp;gt; &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt; &amp;lt;!-- 生成的源代码目录 --&amp;gt; &amp;lt;srcPath&amp;gt;${basedir}/src/main/java&amp;lt;/srcPath&amp;gt; &amp;lt;!-- 生成源代码包前缀 --&amp;gt; &amp;lt;packagePrefixName&amp;gt;com.example.mqwebservice.service.&amp;lt;/packagePrefixName&amp;gt; &amp;lt;/tars2JavaConfig&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;!--package plugin--&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 注解main @SpringBootApplication @EnableTarsServer public class MqwebserviceApplication { public static void main(String[] args) { SpringApplication.</description>
    </item>
    
    <item>
      <title>实现tars-springboot-ibm-mq的微服务(微服务系列第二天)</title>
      <link>https://aomi.run/posts/java/hello-java-2-day/</link>
      <pubDate>Wed, 27 Jan 2021 12:37:57 +0800</pubDate>
      
      <guid>https://aomi.run/posts/java/hello-java-2-day/</guid>
      <description>前言  学习JAVA第2天 目标实现： 基于tars springboot ibm mq的微服务
 第1天学习了java的项目创建，打包，上传到tars中，收获良多，今天折腾一下项目中需要用到的IBM MQ消息服务,于是就实现了基于tars springboot ibm mq的微服务.
搭建IBM MQ 同样还是使用docker来创建，添加ibmmq
$ docker volume create qm1data # ibm mq 有些权限要求，配置不当有可能启动不了，所以使用卷的方式比较简单 docker-compose.yml 中添加内容如下：
ibmmq:image:ibmcom/mqcontainer_name:ibmmqvolumes:- qm1data:/mnt/mqmenvironment:LICENSE:&amp;#34;accept&amp;#34;MQ_QMGR_NAME:&amp;#34;QM1&amp;#34;MQ_APP_PASSWORD:&amp;#34;abcd1234&amp;#34;ports:- &amp;#34;1414:1414&amp;#34;- &amp;#34;9443:9443&amp;#34;networks:tars:ipv4_address:172.25.0.201volumes:qm1data:另外给node一个web服务端口，后续会用上
node:# image: tarscloud/tars-node:stableimage:tarscloud/tars-node:latestcontainer_name:tars-node# restart: alwaysports:- &amp;#34;1080:1080&amp;#34;networks:tars:ipv4_address:172.25.0.5volumes:- ./node/data:/data/tars:rw- /etc/localtime:/etc/localtimeenvironment:INET:eth0WEB_HOST:http://172.25.0.3:3000depends_on:- framework运行起来
$ docker-compose up -d Creating tars-mysql ... done Creating ibmmq ... done Creating tars-framework ... done Creating tars-node ... done 打开浏览器访问一下，并做相应的配置 https://localhost:9443 重要！！！ 9443是SSL端口，一定需要使用https来访问,好像ibmmq这个版本的web服务有bug,重启Docker后，会占用端口，之后就启动不了了，原因没有深究，测试的话，默认创建好后就可以使用，要不要Web管理端都无所谓。
IBM MQ登录页 输入账号密码登录，默认账号密码是： admin/passw0rd
IBM MQ登录后的欢迎页 版本信息 新版本的IBM MQ的界面还是很漂亮的</description>
    </item>
    
    <item>
      <title>通过docker-springboot-tars构建微服务环境(微服务系列第一天)</title>
      <link>https://aomi.run/posts/java/hello-java-1-day/</link>
      <pubDate>Tue, 26 Jan 2021 11:39:02 +0800</pubDate>
      
      <guid>https://aomi.run/posts/java/hello-java-1-day/</guid>
      <description>前言  学习JAVA第1天,实现目标：通过docker整合springboot和tars
 先花了些时间折腾了一下Java的开发环境，平常主要用vscode做开发，就在VScode上弄了一套Java的开发环境，基于win10 wsl2 vscode 的，具体环境折腾可以看我那篇环境搭建的文章。然后花了几个小时时间学习一下Java的基本语法，有哪些保留字，变量的作用域。包、接口、类还有继承关系，和其它语言参照学习一下。打算使用Java做一些项目的补充，则需要多语言混合开发，我选了较熟的Tars来做。Tars原生支持SpringBoot，OK开始折腾。
tars 环境搭建 为了快速开始，我使用Docker来搭建开发环境,Docker的安装及使用搜索网络文章介绍即可。
创建 Docker 网络 $ docker network create -d bridge --subnet=172.25.0.0/16 --gateway=172.25.0.1 tars 创建 docker 目录 $ mkdir ~/docker-app/tars/framework/data -p $ mkdir ~/docker-app/tars/framework-slave/data -p $ mkdir ~/docker-app/tars/node/data -p $ mkdir ~/docker-app/tars/mysql/data -p $ mkdir ~/docker-app/tars/mysql/conf -p 创建 ~/docker-app/tars/mysql/conf/my.cnf 文件 [mysqld] user=root default-storage-engine=INNODB character-set-server=utf8 [client] default-character-set=utf8 [mysql] default-character-set=utf8 创建 ~/docker-app/tars/docker-compose.yml 文件 version:&amp;#34;3&amp;#34;services:mysql:image:mysql:5.6container_name:tars-mysqlports:- &amp;#34;3307:3306&amp;#34;# restart: alwaysprivileged:trueenvironment:MYSQL_ROOT_PASSWORD:&amp;#34;123456&amp;#34;volumes:- ./mysql/data:/var/lib/mysql- ./mysql/conf/my.cnf:/etc/my.cnf- /etc/localtime:/etc/localtimenetworks:tars:ipv4_address:172.25.0.2framework:# image: tarscloud/framework:stableimage:tarscloud/framework:latestcontainer_name:tars-frameworkports:- &amp;#34;3000:3000&amp;#34;- &amp;#34;3001:3001&amp;#34;# restart: alwaysnetworks:tars:ipv4_address:172.</description>
    </item>
    
    <item>
      <title>Wsl2 Vscode Openjdk Install</title>
      <link>https://aomi.run/posts/wsl2-vscode-openjdk-install/</link>
      <pubDate>Mon, 25 Jan 2021 11:46:59 +0800</pubDate>
      
      <guid>https://aomi.run/posts/wsl2-vscode-openjdk-install/</guid>
      <description>准备 进入wsl命令行，先更新系统,更新慢的可以换apt源处理，换源自行搜索。
$ sudo apt update -y $ sudo apt upgrade -y 安装JDK 安装 JDK 8 $ sudo apt install openjdk-8-jdk -y /usr/lib/jvm/java-8-openjdk-amd64 #我电脑安装的位置 $ java -version openjdk version &amp;#34;1.8.0_275&amp;#34; OpenJDK Runtime Environment (build 1.8.0_275-8u275-b01-0ubuntu1~20.04-b01) OpenJDK 64-Bit Server VM (build 25.275-b01, mixed mode) 装个 JDK 11 $ sudo apt install openjdk-11-jdk -y /usr/lib/jvm/java-11-openjdk-amd64 #我电脑安装的位置 JDK版本切换 $ sudo update-alternatives --install /usr/local/jdk jdk /usr/lib/jvm/java-8-openjdk-amd64 8 $ sudo update-alternatives --install /usr/local/jdk jdk /usr/lib/jvm/java-11-openjdk-amd64 11 $ sudo update-alternatives --config jdk There are 2 choices for the alternative jdk (providing /usr/local/jdk).</description>
    </item>
    
    <item>
      <title>启动 WSL 2时警告“参考的对象类型不支持尝试的操作”</title>
      <link>https://aomi.run/posts/wsl-error/</link>
      <pubDate>Sat, 23 Jan 2021 00:15:05 +0800</pubDate>
      
      <guid>https://aomi.run/posts/wsl-error/</guid>
      <description>出现图中所示错误的原因是 代理软件与 wsl2 的端口冲突。
使用 NoLsp.exe 下载链接 如果浏览器打不开 可以用迅雷之类的来下载
使用管理员身份运行以下命令:
NoLsp.exe C:\Windows\system32\wsl.exe  参数为 wsl 的绝对路径（默认为 C:\Windows\system32\wsl.exe）
 问题原因及解决方案的讨论见 Gihub Issue</description>
    </item>
    
    <item>
      <title>7天用Go从零实现Web框架</title>
      <link>https://aomi.run/posts/golang/realizing-web-framework-from-scratch-with-go-in-7-days/</link>
      <pubDate>Thu, 21 Jan 2021 17:35:50 +0800</pubDate>
      
      <guid>https://aomi.run/posts/golang/realizing-web-framework-from-scratch-with-go-in-7-days/</guid>
      <description>序言 在网上看到一个不错的教程，为了自己记录方便，转载一下。源站地址 极客兔兔
设计一个框架 大部分时候，我们需要实现一个 Web 应用，第一反应是应该使用哪个框架。不同的框架设计理念和提供的功能有很大的差别。比如 Python 语言的 django和flask，前者大而全，后者小而美。Go语言/golang 也是如此，新框架层出不穷，比如Beego，Gin，Iris等。那为什么不直接使用标准库，而必须使用框架呢？在设计一个框架之前，我们需要回答框架核心为我们解决了什么问题。只有理解了这一点，才能想明白我们需要在框架中实现什么功能。
我们先看看标准库net/http如何处理一个请求。
func main() { http.HandleFunc(&amp;#34;/&amp;#34;, handler) http.HandleFunc(&amp;#34;/count&amp;#34;, counter) log.Fatal(http.ListenAndServe(&amp;#34;localhost:8000&amp;#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;URL.Path = %qn&amp;#34;, r.URL.Path) } net/http提供了基础的Web功能，即监听端口，映射静态路由，解析HTTP报文。一些Web开发中简单的需求并不支持，需要手工实现。
 动态路由：例如hello/:name，hello/*这类的规则。 鉴权：没有分组/统一鉴权的能力，需要在每个路由映射的handler中实现。 模板：没有统一简化的HTML机制。 …  当我们离开框架，使用基础库时，需要频繁手工处理的地方，就是框架的价值所在。但并不是每一个频繁处理的地方都适合在框架中完成。Python有一个很著名的Web框架，名叫bottle，整个框架由bottle.py一个文件构成，共4400行，可以说是一个微框架。那么理解这个微框架提供的特性，可以帮助我们理解框架的核心能力。
 路由(Routing)：将请求映射到函数，支持动态路由。例如&amp;rsquo;/hello/:name。 模板(Templates)：使用内置模板引擎提供模板渲染机制。 工具集(Utilites)：提供对 cookies，headers 等处理机制。 插件(Plugin)：Bottle本身功能有限，但提供了插件机制。可以选择安装到全局，也可以只针对某几个路由生效。 …  HTTP 基础 标准库启动Web服务 Go语言内置了 net/http库，封装了HTTP网络编程的基础的接口，我们实现的Gee Web 框架便是基于net/http的。我们接下来通过一个例子，简单介绍下这个库的使用。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/&amp;#34;, indexHandler) http.</description>
    </item>
    
    <item>
      <title>Markdown 中文说明</title>
      <link>https://aomi.run/posts/document/markdown-readme/</link>
      <pubDate>Thu, 21 Jan 2021 14:33:04 +0800</pubDate>
      
      <guid>https://aomi.run/posts/document/markdown-readme/</guid>
      <description>NOTE: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax.
 概述 宗旨 Markdown 的目标是实现「易读易写」。
可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。
总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像_强调_。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。
兼容 HTML Markdown 语法的目标是：成为一种适用于网络的_书写_语言。
Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想_不是_要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种_发布_的格式，Markdown 是一种_书写_的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。
不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。
要制约的只有一些 HTML 区块元素――比如 、、、 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 `` 标签。</description>
    </item>
    
    <item>
      <title>edge如何解决跨域问题</title>
      <link>https://aomi.run/posts/edge-cors-error/</link>
      <pubDate>Wed, 20 Jan 2021 23:42:51 +0800</pubDate>
      
      <guid>https://aomi.run/posts/edge-cors-error/</guid>
      <description>找了一个比较简单的解决办法 去应用商店直接下载一个插件 Access-Control-Allow-Origin,装好了之后点图标，点击toggle把上面的logo点成彩色，然后刷新一下需要跨域的页面，完成 </description>
    </item>
    
  </channel>
</rss>